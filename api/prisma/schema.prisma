generator client {
  provider      = "prisma-client-js"
  binaryTargets = ["native", "debian-openssl-1.0.x"]
}

datasource db {
  provider = "mysql"
  url      = env("DATABASE_URL")
}

enum Role {
  ADMIN
  TEACHER
  STUDENT
  LICENSE
}

// Replaced enum Subject with Subject table for easier management
model Subject {
  id   Int     @id @default(autoincrement())
  name String
  code String? @unique

  questions Question[]
  exams     Exam[]
}

enum QuestionType {
  SC // single choice
  MC // multi choice
  TEXT // short text
}

enum AttemptStatus {
  IN_PROGRESS
  SUBMITTED
  GRADED
}

model User {
  id        Int      @id @default(autoincrement())
  email     String?  @unique
  password  String
  fullName  String?
  userCode  String?  @unique
  subjectId Int?
  role      Role
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  questionsAuthored Question[] @relation("QuestionAuthor")
  roomsCreated      Room[]     @relation("RoomCreator")
  attempts          Attempt[]
  exams             Exam[]     @relation("ExamAuthor")
}

model Question {
  id          Int          @id @default(autoincrement())
  subject     Subject      @relation(fields: [subjectId], references: [id], onDelete: Restrict)
  subjectId   Int
  type        QuestionType
  text        String // nội dung câu hỏi
  explanation String? // giải thích sau khi nộp
  correctText String? // dùng khi type=TEXT (so khớp chính xác/ gần đúng do app xử)
  author      User?        @relation("QuestionAuthor", fields: [authorId], references: [id], onDelete: SetNull)
  authorId    Int?
  isActive    Boolean      @default(true)
  createdAt   DateTime     @default(now())

  choices        Choice[] // cho SC/MC
  examLinks      ExamQuestion[]
  attemptAnswers AttemptAnswer[]

  @@index([subjectId, type])
}

model Choice {
  id                   Int                   @id @default(autoincrement())
  question             Question              @relation(fields: [questionId], references: [id], onDelete: Cascade)
  questionId           Int
  content              String
  isCorrect            Boolean               @default(false) // dùng cho SC/MC
  order                Int                   @default(0)
  attemptAnswerChoices AttemptAnswerChoice[]

  @@index([questionId])
}

model Exam {
  id          Int        @id @default(autoincrement())
  title       String
  description String?
  code        String?    @unique
  status      ExamStatus @default(DRAFT)

  // === Phân loại (tùy chọn) ===
  subjectId Int?
  subject   Subject? @relation(fields: [subjectId], references: [id], onDelete: SetNull)

  // === Loại đề & quy tắc chấm ===
  examType        ExamType    @default(PRACTICE)
  totalPoints     Decimal?    @db.Decimal(8, 2) // tổng điểm, có thể tính tự động
  passMarkPercent Int? // ngưỡng đậu (%)
  scoringMode     ScoringMode @default(STANDARD)

  // === Cấu hình feedback ===
  feedbackMode         FeedbackMode @default(DETAILED)
  showScoreImmediately Boolean      @default(true)
  showCorrectAnswers   Boolean      @default(false)
  showExplanation      Boolean      @default(false)
  reviewWindowMin      Int?

  // === Tác giả & thời gian ===
  author    User?    @relation("ExamAuthor", fields: [authorId], references: [id], onDelete: SetNull)
  authorId  Int?
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // === Quan hệ ===
  items    ExamQuestion[]
  rooms    Room[]
  attempts Attempt[]

  @@index([subjectId])
  @@index([status])
}

enum ExamStatus {
  DRAFT
  PUBLISHED
  ARCHIVED
}

enum ExamType {
  PRACTICE
  MIDTERM
  FINAL
  MOCK
  MOS_DRILL
  PLACEMENT
}

enum ScoringMode {
  STANDARD // đúng = đủ điểm, sai = 0
  PARTIAL_CREDIT // MC cho điểm phần đúng
  NEGATIVE_MARKING // trừ điểm đoán bừa (nếu bạn áp dụng)
}

enum FeedbackMode {
  NONE // không hiện gì sau khi nộp
  AFTER_SUBMIT // hiện điểm/đáp án sau khi nộp
  DETAILED // hiện giải thích theo câu (nếu có)
}

model ExamQuestion {
  exam       Exam     @relation(fields: [examId], references: [id], onDelete: Cascade)
  examId     Int
  question   Question @relation(fields: [questionId], references: [id], onDelete: Restrict)
  questionId Int
  points     Decimal  @default(1.00) @db.Decimal(6, 2)
  order      Int      @default(0)

  @@id([examId, questionId])
  @@index([questionId])
}

model Room {
  id               Int       @id @default(autoincrement())
  exam             Exam      @relation(fields: [examId], references: [id], onDelete: Cascade)
  examId           Int
  code             String    @unique // dùng làm link: /r/{code}
  isProtected      Boolean   @default(false)
  password         String?
  openAt           DateTime?
  closeAt          DateTime?
  durationSec      Int? // thời lượng mỗi thí sinh (giống nhau)
  shuffleQuestions Boolean   @default(true)
  shuffleChoices   Boolean   @default(true)
  maxAttempts      Int       @default(1)
  createdBy        User?     @relation("RoomCreator", fields: [createdById], references: [id], onDelete: SetNull)
  createdById      Int?
  createdAt        DateTime  @default(now())

  attempts Attempt[]

  @@index([examId])
  @@index([openAt, closeAt])
}

model Attempt {
  id           Int           @id @default(autoincrement())
  room         Room          @relation(fields: [roomId], references: [id], onDelete: Cascade)
  roomId       Int
  exam         Exam          @relation(fields: [examId], references: [id], onDelete: Cascade)
  examId       Int
  student      User          @relation(fields: [studentId], references: [id], onDelete: Cascade)
  studentId    Int
  status       AttemptStatus @default(IN_PROGRESS)
  startedAt    DateTime      @default(now())
  submittedAt  DateTime?
  score        Decimal?      @db.Decimal(8, 2)
  timeTakenSec Int?

  answers AttemptAnswer[]

  @@unique([roomId, studentId]) // mỗi phòng chỉ được 1 lượt (đổi nếu muốn nhiều lượt)
  @@index([roomId])
  @@index([examId])
  @@index([studentId])
}

model AttemptAnswer {
  id         Int      @id @default(autoincrement())
  attempt    Attempt  @relation(fields: [attemptId], references: [id], onDelete: Cascade)
  attemptId  Int
  question   Question @relation(fields: [questionId], references: [id], onDelete: Cascade)
  questionId Int

  // cho TEXT
  textAnswer String?
  // chấm điểm/đúng-sai (app tính, lưu lại để xem)
  isCorrect  Boolean?
  earned     Decimal? @db.Decimal(6, 2)

  choices AttemptAnswerChoice[] // cho SC/MC

  @@unique([attemptId, questionId])
  @@index([questionId])
}

model AttemptAnswerChoice {
  // mapping các lựa chọn user đã chọn (hỗ trợ MC nhiều lựa chọn)
  attemptAnswer   AttemptAnswer @relation(fields: [attemptAnswerId], references: [id], onDelete: Cascade)
  attemptAnswerId Int
  choice          Choice        @relation(fields: [choiceId], references: [id], onDelete: Cascade)
  choiceId        Int

  @@id([attemptAnswerId, choiceId])
  @@index([choiceId])
}
